<?php
/**
 * Session library file
 *
 * See {@link AeSession} class documentation.
 *
 * @author Anton Suprun <kpobococ@gmail.com>
 * @version 1.0
 * @package AnEngine
 * @todo add subpackage once custom documentor is done //Framework
 */

/**
 * Session library
 *
 * This is a basic session handler. It provides sufficient interface to handle
 * all the session data and sets the session cookie. You can also use this with
 * standard php session functions, just by creating an instance of the class
 * somewhere so that custom storage methods get registered.
 *
 * @author Anton Suprun <kpobococ@gmail.com>
 * @version 1.0
 * @package AnEngine
 * @todo add subpackage once custom documentor is done //Framework
 */
class AeSession extends AeNode_Nested
{
    const STATE_ACTIVE    = 1;
    const STATE_EXPIRED   = 2;
    const STATE_DESTROYED = 3;
    const STATE_ERROR     = 4;

    const DEFAULT_CONNECTION = 'default';

    /**
     * Session state
     *
     * One of the STATE constants
     *
     * @see AeSession::STATE_ACTIVE, AeSession::STATE_EXPIRED,
     *      AeSession::STATE_DESTROYED, AeSession::STATE_ERROR
     *
     * @var int
     */
    protected $_state;

    /**
     * Session length in seconds
     * @var int
     */
    protected $_expire = false;

    /**
     * Session validating options
     * @var array
     */
    protected $_validate = array();

    /**
     * Session driver connector
     * @var AeInterface_Session
     */
    protected $_connection;

    /**
     * Key name matching pattern
     *
     * Failure to match a key name to this pattern will trigger an exception
     *
     * @var string
     */
    protected $_keyPattern = '#^[_a-z][._a-z0-9]*$#i';

    /**
     * Get session instance
     *
     * Returns an instance of the AeSession class
     *
     * @param string $driver  Session storage driver to use
     * @param array  $options Session options
     *
     * @return AeSession
     */
    public static function getInstance($driver = null, $options = null)
    {
        $args = func_get_args();

        if (is_array($args[1])) {
            $args[1] = new AeArray($args[1]);
        }

        return AeInstance::get('AeSession', $args, true, false);
    }

    /**
     * Get session connection
     *
     * Reads session configuration from the specified configuration file and
     * creates the appropriate session. Created session is started automatically
     *
     * @param string $name     name of the connection
     * @param string $settings path to custom configuration file
     *
     * @return AeSession
     */
    public static function getConnection($name = null, $settings = null)
    {
        $name = $name !== null ? $name : self::DEFAULT_CONNECTION;

        if ($settings === null || !file_exists($settings)) {
            $file = 'ae'.SLASH.'session.ini';
        } else {
            $file = $settings;
        }

        $settings = AeSettings::getInstance($settings);
        $driver   = $settings->get($name.'.driver' , null);
        $options  = $settings->get($name.'.options', null);

        try {
            $connection = self::getInstance($driver, $options);
            $connection->start();
        } catch (AeSessionException $e) {
            // *** Driver exception while connecting
            switch ($e->getCode())
            {
                case '400': {
                    throw new AeSessionException(ucfirst($name) . ' connection load failed: bad configuration', 500);
                } break;

                default: {
                    throw $e;
                } break;
            }

            // *** Exception while loading driver
            throw $e;
        }

        return $connection;
    }

    /**
     * Constructor
     *
     * Initializes the session. Any sessions, already started, will be
     * immediately destroyed.
     *
     * The following options can be set by the <var>$options</var> parameter:
     * - name      string Session cookie name to use for session identification;
     * - id        string Session cookie contents. You are advised to not set
     *                    this manually, as an id is generated by PHP by default;
     * - expire    int    Session length in seconds;
     * - validate  array  Session validation options:
     *   - address bool   Validation of user's remote address (IP);
     *   - agent   bool   Validation of user's user-agen (browser);
     * - path      string Session cookie path. Defaults to /. If the similar
     *                    option is set via {@link AeCookie::setPath()}, that
     *                    value is used as default instead;
     * - domain    string Session cookie domain. Defaults to current domain. If
     *                    the similar option is set via {@link
     *                    AeCookie::setDomain()}, that value is used as default
     *                    instead;
     * - secure    bool   If is true, the session cookie is only set using the
     *                    secure connection (https). If the similar option is
     *                    set via {@link AeCookie::setPath()}, that value is
     *                    used as default instead;
     * - http      bool   If is true, the session cookie is set in the httponly
     *                    mode. See {@link http://php.net/setcookie setcookie()}
     *                    for more details. Requires PHP 5.2.0. If the similar
     *                    option is set via {@link AeCookie::setHttp()}, that
     *                    value is used as default instead;
     *
     * Also, a 'driver' subarray of the options array will be passed as options
     * to the session storage driver. See storage driver options on the driver's
     * class documentation page.
     *
     * @param string  $driver  session storage driver name
     * @param AeArray $options session options
     */
    public function __construct($driver = null, AeArray $options = null)
    {
        // *** Destroy any existing sessions
        if (session_id()) {
            session_unset();
            session_destroy();
        }

        // *** Set default sessions save handler
        ini_set('session.save_handler', 'files');

        // *** Disable transparent sid support
        ini_set('session.use_trans_sid', '0');

        // *** Create connection
        $this->_connection = AeSession_Driver::getInstance($driver, $options['driver']);

        $this->_setOptions($options);
    }

    /**
     * Start session
     *
     * Starts the session, setting the cookie and session state and validating
     * the session parameters, according to the validation options set.
     *
     * @return bool
     */
    public function start()
    {
        if ($this->_state == self::STATE_ACTIVE) {
            return true;
        }

        session_cache_limiter('none');
        session_start();

        // *** Send modified header for IE 6.0 Security Policy
        header('P3P: CP="NOI ADM DEV PSAi COM NAV OUR OTRo STP IND DEM"');

        $this->_state =	self::STATE_ACTIVE;
        $this->_start();

        // *** Perform security checks
        return $this->_validate();
    }

    /**
     * Clear session variable
     *
     * Removes the session variable, identified by the <var>$name</var>
     * parameter
     *
     * @uses AeSession::_check() to check for session state
     *
     * @throws AeSessionException #403 if session validation failed
     * @throws AeSessionException #408 if session has expired
     * @throws AeSessionException #412 if session has been destroyed
     *
     * @param string $name
     *
     * @return bool|mixed
     */
    public function clear($name)
    {
        if (!$this->_check()) {
            return false;
        }

        $this->_clearByKey((string) $name, $_SESSION);

        return true;
    }

    /**
     * Set session variable
     *
     * Sets the session variable, identified by the <var>$name</var> parameter,
     * to the value passed
     *
     * @uses AeSession::_check() to check for session state
     *
     * @throws AeSessionException #403 if session validation failed
     * @throws AeSessionException #408 if session has expired
     * @throws AeSessionException #412 if session has been destroyed
     *
     * @param string $name
     * @param mixed  $value
     *
     * @return bool
     */
    public function set($name, $value)
    {
        $name = (string) $name;

        if ($this->propertyExists($name, 'set')) {
            return parent::set($name, $value);
        }

        if (!$this->_check()) {
            return false;
        }

        if (!preg_match($this->_keyPattern, $name)) {
            throw new AeSessionException('Key name is invalid', 400);
        }

        return $this->_setByKey((string) $name, $value, $_SESSION);
    }

    /**
     * Get session variable
     *
     * Returns the session variable, identified by the <var>$name</var>
     * parameter, or the <var>$default</var>, if variable is not set or is null
     *
     * @uses AeSession::_check() to check for session state
     *
     * @throws AeSessionException #403 if session validation failed
     * @throws AeSessionException #408 if session has expired
     * @throws AeSessionException #412 if session has been destroyed
     *
     * @param string $name
     * @param mixed  $default
     *
     * @return object|AeScalar|AeArray
     */
    public function get($name, $default = null)
    {
        $name = (string) $name;

        if ($this->propertyExists($name)) {
            // *** Never wrap object properties
            return parent::get($name, $default);
        }

        if (!$this->_check()) {
            return false;
        }

        if (!preg_match($this->_keyPattern, (string) $name)) {
            throw new AeSessionException('Key name is invalid', 400);
        }

        $return = $this->_getByKey((string) $name, $_SESSION);

        return AeType::wrapReturn($return, $default);
    }

    /**
     * Close session
     *
     * See {@link http://php.net/session_write_close session_write_close()}
     * for more details
     *
     * @return bool
     */
    public function close()
    {
        @session_write_close();

        return true;
    }

    /**
     * Destroy session
     *
     * This method resets the $_SESSION variable and destroys all of the data
     * associated with the current session in its storage. It forces new session
     * to be started after this method is called. Also unsets the session cookie
     *
     * See {@link http://php.net/session_unset session_unset()} and {@link
     * http://php.net/session_destroy session_destroy()} for more details
     *
     * @return bool
     */
    public function destroy()
    {
        if ($this->_state === self::STATE_DESTROYED) {
            return true;
        }

        if (isset($_COOKIE[$this->getName()]))
        {
            $params = session_get_cookie_params();
            $args   = array($this->getName());
            $args[] = $params['path'];
            $args[] = $params['domain'];
            $args[] = $params['secure'];

            if (version_compare(PHP_VERSION, '5.2.0', '>=')) {
                $args[] = $params['httponly'];
            }

            @call_user_func_array(array('AeCookie', 'clear'), $args);
        }

        session_unset();
        session_destroy();

        $this->_state = self::STATE_DESTROYED;

        return true;
    }

    /**
     * Get session id
     *
     * Returns the id of the current session
     *
     * See {@link http://php.net/session_id session_id()} for more details
     *
     * @throws AeSessionException #412 if session has been destroyed
     *
     * @return string
     */
    function getId()
    {
        if ($this->_state === self::STATE_DESTROYED) {
            throw new AeSessionException('ID detection failed: session destroyed', 412);
        }

        return @session_id();
    }

    /**
     * Get session name
     *
     * Returns the name of the current session
     *
     * See {@link http://php.net/session_name session_name()} for more details
     *
     * @throws AeSessionException #412 if session has been destroyed
     *
     * @return <type>
     */
    function getName()
    {
        if ($this->_state === self::STATE_DESTROYED) {
            throw new AeSessionException('Name detection failed: session destroyed', 412);
        }

        return @session_name();
    }

    /**
     * Initialize session
     *
     * Initializes the following internal session params:
     * - time.start int session creation time (unix timestamp)
     * - time.last  int session last refresh time (unix timestamp)
     * - time.now   int session current time (unix timestamp)
     *
     * @return bool
     */
    protected function _start()
    {
        // *** Initialise internal session parameters
        if (!$this->get('time.start', false)) {
            $start = time();

            $this->set('time.start', $start);
            $this->set('time.last' , $start);
            $this->set('time.now'  , $start);
        }

        $this->set('time.last', (int) $this->get('time.now')->value);
        $this->set('time.now' , time());

        return true;
    }

    /**
     * Validate session
     *
     * Validates current session, using validation options specified. See {@link
     * AeSession::__construct() session constructor} for details on the
     * available validation options.
     *
     * If session is expired, the session's {@link AeSession::$_state state}
     * parameter is set to {@link AeSession::STATE_EXPIRED}. If session fails
     * any of the validations, the session's {@link AeSession::$_state state}
     * parameter is set to {@link AeSession::STATE_ERROR}. Returns false in both
     * cases
     *
     * @return bool true if validation is passed, false otherwise
     */
    protected function _validate()
    {
        // *** Check if session has expired
        if ($this->_expire)
        {
            $curTime = (int) $this->get('time.now', new AeInteger(0))->value;
            $maxTime = (int) $this->get('time.last', new AeInteger(0))->value + $this->_expire;

            // *** Empty session variables
            if ($maxTime < $curTime) {
                $this->_state = self::STATE_EXPIRED;
                return false;
            }
        }

        // *** Record proxy forwarded for
        if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {
            $this->set('client.forwarded', $_SERVER['HTTP_X_FORWARDED_FOR']);
        }

        // *** Check for client adress
        if ($this->_validate['remote-address'] && isset($_SERVER['REMOTE_ADDR']))
        {
            $ip = $this->get('client.address');

            if ($ip === null) {
                // *** Session is being created
                $this->set('client.address', $_SERVER['REMOTE_ADDR']);
            } else if ($_SERVER['REMOTE_ADDR'] !== (string) $ip) {
                $this->_state = self::STATE_ERROR;
                return false;
            }
        }

        // *** Check for clients browser
        if ($this->_validate['user-agent'] && isset($_SERVER['HTTP_USER_AGENT']))
        {
            $browser = $this->get('client.browser');

            if ($browser === null) {
                // *** Session is being created
                $this->set('client.browser', $_SERVER['HTTP_USER_AGENT']);
            } else if ($_SERVER['HTTP_USER_AGENT'] !== (string) $browser) {
                $this->_state = self::STATE_ERROR;
                return false;
            }
        }

        return true;
    }

    /**
     * Set session options
     *
     * Sets the session options to the values passed. See {@link
     * AeSession::__construct() session constructor} for details on the
     * available session options.
     *
     * @param AeArray $options
     *
     * @return bool
     */
    protected function _setOptions(AeArray $options)
    {
        // *** Set some options
        if (isset($options['name'])) {
            session_name((string) $options['name']);
        }

        if (isset($options['id'])) {
            session_id((string) $options['id']);
        }

        if (isset($options['expire'])) {
            $this->_expire = (int) $options['expire']->toInteger()->value;
        }

        // *** get security options
        $this->_validate = array(
            'remote-address' => false,
            'user-agent'     => false
        );

        if (isset($options['validate']))
        {
            if (isset($options['validate']['address'])) {
                $this->_validate['remote-address'] = (bool) $options['validate']['address']->getValue();
            }

            if (isset($options['validate']['agent'])) {
                $this->_validate['user-agent'] = (bool) $options['validate']['agent']->getValue();
            }
        }

        // *** Sync the session maxlifetime
        ini_set('session.gc_maxlifetime', $this->_expire);

        $cookie = session_get_cookie_params();
        $args   = array();

        $args[] = $this->_expire;
        $args[] = isset($options['path'])   ? (string) $options['path']   : (string) AeCookie::getPath($cookie['path']);
        $args[] = isset($options['domain']) ? (string) $options['domain'] : (string) AeCookie::getDomain($cookie['domain']);
        $args[] = isset($options['secure']) ? (bool) $options['secure']->toBoolean()->value : (bool) AeCookie::getSecure(new AeBoolean($cookie['secure']))->toBoolean()->value;

        if (version_compare(PHP_VERSION, '5.2.0', '>=')) {
            $args[] = isset($options['http']) ? (bool) $options['http']->toBoolean()->value : (bool) AeCookie::getHttp(new AeBoolean((bool) @$cookie['http']))->toBoolean()->value;
        }

        return @call_user_func_array('session_set_cookie_params', $args);
    }

    /**
     * Check session state
     *
     * Checks the current session state and returns true, if session is active,
     * false if the state is unknown. Otherwise throws an exception with the
     * correct message to describe the session state
     *
     * @throws AeSessionException #403 if session validation failed
     * @throws AeSessionException #408 if session has expired
     * @throws AeSessionException #412 if session has been destroyed
     *
     * @return bool true if session is active, false otherwise
     */
    protected function _check()
    {
        if ($this->_state === self::STATE_ACTIVE) {
            return true;
        }

        switch ($this->_state)
        {
            case self::STATE_EXPIRED: {
                throw new AeSessionException('Session has expired', 408);
            } break;

            case self::STATE_ERROR: {
                throw new AeSessionException('Session validation failed', 403);
            } break;

            case self::STATE_DESTROYED: {
                throw new AeSessionException('Session has been destroyed', 412);
            } break;
        }

        return false;
    }
}

/**
 * Session exception class
 *
 * Session-specific exception class
 *
 * @author Anton Suprun <kpobococ@gmail.com>
 * @version 1.0
 * @package AnEngine
 * @todo add subpackage once custom documentor is done //Exception
 */
class AeSessionException extends AeLibraryException
{
    /**
     * @param string $message
     * @param int    $code
     */
    public function __construct($message, $code = 500)
    {
        $this->_appendPrefix('Session');
        parent::__construct($message, $code);
    }
}
?>